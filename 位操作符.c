#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

#if 0
int main()
{
	/*
	>>右移操作符
	1.算术右移
		右边丢弃，左边补原符号位
	2.逻辑右移
		右边丢弃，左边补0
	和编译环境有关
	*/
	
	int a = 16;
	//>>右移操作符
	//移动的是二进制位
	//00000000000000000000000000010000
	int b = a >> 1;//（正整数）右移1位有除2的效果
	//00000000000000000000000000001000	8
	printf("%d\n",b);


	int c = -1;
	//存储到内存的是补码
	//原码：10000000000000000000000000000001
	//反码：11111111111111111111111111111110
	//补码：11111111111111111111111111111111
	//补码移位(+算术移位)：1111111111111111111111111111111
	//>>右移操作符
	//移动的是二进制位
	//10000000000000000000000000000001
	int d = c >> 1;
	//00000000000000000000000000001000	8
	printf("%d\n", d);

	int e = 5;		//00000000000000000000000000000101
	printf("%d\n", (e << 1));//0000000000000000000000000001010		//（正整数）10右移1位有乘2的效果



	/*
	&	|	^
	*/
	//异或^
	//相异为1，相同为0
	int f = 3;
	int g = 5;
	printf("%d\n",f^g);
	//011
	//101
	//110	//6

	int h = 3;
	int i = 5;
	//加减法交换h,i
	h = h + i;  //8
	i = h - i;  //3
	h = h - i;  //5
	printf("%d\n",h);
	//缺陷，如果h和i很大可能会溢出

	//异或法
	h = h ^ i;	//6
	i = h ^ i;	//3		h异或了2次i还是本来的h
	h = h ^ i;	//5		i被异或的次数比h多一次，那结果还是i
	printf("%d\n", h);
	return 0;
}

#elif 0
/*
	计算补码个数
*/
int main()
{
	int num = 0;
	scanf("%d", &num);		//011
	int i = 0;		
	int count = 0;
	for (int i = 0; i < 32; i++)
	{
		if (1 == ((num >> i) & 1))	//011 & 001 = 001		001 & 001	把计算过的1一位一位的丢掉，左边补0
		{
			count++;
		}
	}
	printf("%d\n", count);
}

#elif 0
int main()
{
	short s = 0;
	int a = 10;
	printf("%d\n", sizeof(s = a + 5));		//2,short类型占2字节
	printf("%d\n", s);						//s = 0
}

#elif 0
int main()
{
	short a = 0;
	//~按位取反
	//00000000 00000000
	//11111111 11111111		-补码
	//11111111 11111110		-反码
	//10000000 00000001		-原码	-1
	printf("%d\n", ~a);		//-1

	int b = 11;		//1011
	//将第2位置1
	b = b | (1 << 2);	//b| 0100
	printf("%d\n", b);
	//将第2位恢复为0
	b = b & (~(1 << 2));	//b& 1011
	printf("%d\n", b);
	return 0;
}

#elif 0
int main()
{
	int a = 10;
	printf("%d\n", ++a);	//前置++，先++后赋值	11
	printf("%d\n",a++);		//后置++,先赋值后++		printf(11)  a = 12
	return 0;
}

#elif 0
int main()
{
	int i = 0, a = 0, b = 2, c = 3, d = 4;
	i = a++ && ++b & d++;	//a先与再++，0&任何数都为0，所以后面的不算了，直接i = 0，&&与逻辑操作符：左边逻辑算出为假，右边不再计算
	printf("a = %d\n b = %d\n c = %d\n d = %d\n", a,b,c,d);	//1,2，3，4

	i = 0, a = 1, b = 2, c = 3, d = 4;
	i = a++ && ++b & d++;	//1 && 3 = 1， 1&4 =1 
	printf("a = %d\n b = %d\n c = %d\n d = %d\n", a, b, c, d);	//2,3,3,5

	i = 0, a = 1, b = 2, c = 3, d = 4;
	i = a++ || ++b || d++;	//逻辑或，左边为真右边不再运算
	printf("a = %d\n b = %d\n c = %d\n d = %d\n", a, b, c, d);	//2,2,3,4

	return 0;
}

#elif 0
/*
	逗号表达式：
	exp1,exp2,exp3,...,expN
	用逗号隔开的多个表达式，从左到右依次执行，整个表达式的结果就是最后一个表达式的结果
*/
int main()
{
	int a = 1;
	int b = 2;
	int c = (a > b, a = b + 10, a, b = a + 1);		//a > b，不产生结果的表达式，a = 2 +10 = 12,a = 12不产生效果，b = 12+1= 13->c = 13
	printf("%d\n", a);//12
	printf("%d\n", b);//13
	printf("%d\n", c);//13

	//
	do
	{
		a = get_value();//业务处理
		count_val(a);
	} while (a > 0);

	//等价于
	while(a = get_value(), count_val(a), a > 0)
	{}
}

#elif 0
//结构体(即类型)
struct Stu
{
	//成员变量
	char name[20];
	int age;
	char id[20];
};
#elif 0
int main()
{
	//使用struct Stu这个结构体类型创建了一个s1对象
	struct Stu s1 = {"张三",20,"20201010"};
	//结构体变量.成员名
	printf("%s\n",s1.name);
	printf("%d\n", s1.age);
	printf("%s\n", s1.id);
	
	//结构体指针->成员名
	struct Stu* ps = &s1;
	printf("%s\n", ps->name);
	printf("%d\n", ps->age);
	printf("%s\n", ps->id);
	return 0;
}
#elif 1
int main()
{
	//隐式变换：char和short类型的数字进行运算时，为确保精度，会暂时提升为整形
	//整形提升：符号位为1，提升位也为1，符号位为0，提升位为0
	char a = 3;	//00000011
	char b = 127;	//01111111
	 
	char c = a + b;		
	//00000000000000000000000000000011		b
	//00000000000000000000000001111111		a
	//00000000000000000000000010000010		a + b
	//赋给c转回char型	：10000010

	printf("%d\n", c);
	//以整数形式打印，所以会将c整形提升
	//c的符号位为1
	//提升后:11111111111111111111111110000010	-补码
	//11111111111111111111111110000001			-1变反码
	//00000000000000000000000001111110			取反变原码

	char zifu = 0xb6;
	short duanzheng = 0xb600;
	int zheng = 0xb6000000;

	if (zifu == 0xb6)	//不打印，zifu与0xb6进行比较运算时，发生了整形提升
		printf("zifu");
	if (duanzheng == 0xb600)	//不打印，duanzheng与0xb600进行比较运算时，发生了整形提升
		printf("duanzheng");
	if (zheng == 0xb6000000)	//打印
		printf("zheng\n");

	

	/*算术转换，两个不同类型的数字进行运算，要将小的先转换为大的类型，再进行运算*/
	return 0;
}
#endif